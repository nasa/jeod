/*
Purpose:
  (Test the eigen rotation to matrix and matrix to eigen rotation capabilities.
   The test involves 3060 test cases. The eigen axis is dispersed over the
   unit sphere by varying the phi (rotation from z) and theta (rotation about z)
   polar coordinates. The eigen rotation is varied from 0 to 180 degrees
   in increments of 22.5 degrees for each eigen axis. This provides much
   more coverage than is required by the cyclomatic complexity of the
   underlying algorithms.

   Each test involves
     1. Computing a transformation matrix from the generated eigen rotation
        using the Trick dsingle_axis_rot function.
     2. Computing a transformation matrix from the generated eigen rotation
        using the Orientation::compute_matrix_from_eigen_rotation method.
     3. Extracting an eigen rotation from the matrix generated by step (2).
     4. Re-computing a transformation matrix from the results of step (3).
     5. Comparing the results of steps (4) and (2) versus those from step (1).)
*/

#include "trick_utils/math/include/trick_math.h"
#include <cmath>
#include <cstdio>

#include "utils/math/include/matrix3x3.hh"
#include "utils/math/include/vector3.hh"
#include "utils/orientation/include/orientation.hh"

#include "test_harness/include/cmdline_parser.hh"
#include "test_harness/include/color_text.hh"

using namespace jeod;

bool test_eigen_rotation(double psi, const double uhat[3], unsigned int icase, bool verbose, ColorText & color);

int main(int argc, char * argv[])
{
    double cosphi, sinphi, phi;
    int ntheta[9];
    double theta, costheta, sintheta;
    double psi;
    double uhat[3];

    double one_eighth_pi = M_PI / 8.0;
    double small_angles[5] = {M_PI * 1e-14, M_PI * 1e-11, M_PI * 1e-8, M_PI * 1e-5, M_PI * 1e-2};

    bool verbose;
    ColorText color;
    CmdlineParser cmdline_parser;

    bool passed = true;
    unsigned int icase = 0;
    unsigned int npassed = 0;

    cmdline_parser.add_switch("verbose", &verbose);
    cmdline_parser.parse(argc, argv);

    for(unsigned icosphi = 0; icosphi <= 16; ++icosphi)
    {
        cosphi = 1.0 - icosphi / 8.0;
        sinphi = std::sqrt(icosphi / 8.0 * (2.0 - icosphi / 8.0));
        phi = std::atan2(sinphi, cosphi);

        unsigned int itheta_max;
        if(icosphi == 0)
        {
            ntheta[0] = -1;
            itheta_max = 0;
        }
        else if(icosphi <= 8)
        {
            ntheta[icosphi] = (unsigned int)(2.0 * M_PI * icosphi * sinphi / phi + 0.5);
            itheta_max = ntheta[icosphi] + 1;
        }
        else
        {
            itheta_max = ntheta[16 - icosphi] + 1;
        }

        for(unsigned itheta = 0; itheta <= itheta_max; ++itheta)
        {
            theta = itheta * one_eighth_pi;
            costheta = std::cos(theta);
            sintheta = std::sin(theta);
            uhat[0] = sinphi * costheta;
            uhat[1] = sinphi * sintheta;
            uhat[2] = cosphi;

            // Test rotations in steps of 22.5 degrees.
            for(unsigned ipsi = 0; ipsi < 9; ++ipsi)
            {
                ++icase;
                psi = ipsi * one_eighth_pi;

                if(test_eigen_rotation(psi, uhat, icase, verbose, color))
                {
                    ++npassed;
                }
                else
                {
                    passed = false;
                }
            }

            // Test cases very close to 0 and 180 degrees.
            for(double small_angle : small_angles)
            {
                ++icase;
                psi = small_angle;

                if(test_eigen_rotation(psi, uhat, icase, verbose, color))
                {
                    ++npassed;
                }
                else
                {
                    passed = false;
                }

                ++icase;
                psi = M_PI - psi;

                if(test_eigen_rotation(psi, uhat, icase, verbose, color))
                {
                    ++npassed;
                }
                else
                {
                    passed = false;
                }
            }
        }
    }

    printf("Made %u tests with %u failures\n", icase, icase - npassed);

    if(passed)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

bool test_eigen_rotation(double psi,           // In:  r Eigen rotation angle
                         const double uhat[3], // In: -- Eigen rotation axis (unit vector)
                         unsigned int icase,   // In: -- Case number, for reporting
                         bool verbose,         // In: -- Generate report even if test passes
                         ColorText & color)    // Inout: -- Color text object
{
    static const double xhat[3] = {1, 0, 0};

    bool case_passed;
    Quaternion quat;
    double trans_quat[3][3];
    double trans_eigen[3][3];
    double trans_test[3][3];
    double dvec[3];
    double psi_step2, uhat_step2[3];
    double psi_err;
    double u_cross_v[3];
    double trans_ang_err;
    double eigen_ang_err;
    bool trans_passed;
    bool eigen_passed;

    // Convert the eigen rotation to a quaternion and then to a matrix.
    quat.left_quat_from_eigen_rotation(psi, uhat);
    quat.left_quat_to_transformation(trans_quat);

    // Convert the eigen rotation to a matrix via the Orientation methods
    Orientation::compute_matrix_from_eigen_rotation(psi, uhat, trans_eigen);

    // The two matrices should be nearly equal.
    // Find the error angle between them.
    Matrix3x3::product_right_transpose(trans_quat, trans_eigen, trans_test);
    dvec[0] = trans_test[1][2] - trans_test[2][1];
    dvec[1] = trans_test[2][0] - trans_test[0][2];
    dvec[2] = trans_test[0][1] - trans_test[1][0];
    trans_ang_err = 0.5 * Vector3::vmag(dvec);
    trans_passed = trans_ang_err < 1e-15;

    // Extract the eigen rotation from the matrix.
    Orientation::compute_eigen_rotation_from_matrix(trans_quat, &psi_step2, uhat_step2);
    psi_err = psi - psi_step2;
    if(std::fpclassify(psi) == FP_ZERO)
    {
        Vector3::cross(xhat, uhat_step2, u_cross_v);
    }
    else
    {
        Vector3::cross(uhat, uhat_step2, u_cross_v);
    }

    eigen_ang_err = std::sqrt(psi_err * psi_err + Vector3::vmagsq(u_cross_v));
    eigen_passed = eigen_ang_err < 1e-15;

    case_passed = trans_passed && eigen_passed;
    if(verbose || !case_passed)
    {
        printf("%4d  %11.8f %11.8f %11.8f  %11.7f  %s  %s\n",
               icase,
               uhat[0],
               uhat[1],
               uhat[2],
               psi * 180.0 / M_PI,
               color.pass_fail(trans_passed, "%9.2e", trans_ang_err).c_str(),
               color.pass_fail(eigen_passed, "%9.2e", eigen_ang_err).c_str());
    }
    return case_passed;
}
